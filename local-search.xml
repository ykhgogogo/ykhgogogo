<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试&quot;亿&quot;问：MySQL中索引有了解吗？</title>
    <link href="/2024/07/05/2024-09-15/"/>
    <url>/2024/07/05/2024-09-15/</url>
    
    <content type="html"><![CDATA[<p>MySQL的知识点很多，其中高频的知识点一定少不了<strong>索引</strong>。当面试官问到索引你有了解吗，我们的回答一定是有！我们回答这类问题的时候应该带着引导性的回答。</p><h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p>索引这个概念我们可以其实和生活中的目录进行类比，MySQL中的索引就是起到了目录的作用，帮助我们在数据库表中快速的找到对应的数据，因为开发者在设计MySQL的时候核心思想之一是<strong>减少IO</strong>。在MySQL中索引存储的数据结构是B+树，在进行增删改查的时候时间复杂度是O(logn)。与不加索引对别，查找为例做的就是一个全表扫描的过程，这样势必会造成效率的低下。索引根据不同的分类方式，他也有多种索引类型。同时作为开发者我们在使用索引，或是选择索引的时候需要知道应该选择什么字段作为索引，什么时候会导致索引失效，如何优化索引等一系列问题。<br>通过上面的介绍，我们能够引导出。。。的多个问题。<br>索引在MySQL中是什么形式存储的？为什么采用B+树而不是B&#x2F;B-树？为什么没有采用数据、哈希表或者跳表？<br>对于第一个问题：MySQL的索引是以B+树的形式进行存储。第二个问题结合第三个问题可以结合起来回答。对于面试官提到的几种数据结构，我们可以对比着看。<br>这个问题回答的过程中我们需要记住MySQL索引结构设计的时候核心思想是为了<strong>减少IO</strong>。假设我们现在MySQL以哈希表进行存储，这时候进行等值查询的考虑非常高，时间复杂度为O(1)，这是哈希表的优势；但是哈希表没法进行范围查询，同时对于联合索引，模糊匹配，最左匹配这些功能都没发很好的支持，以模糊匹配为例说明原因：哈希表存储的时候会对key进行hash计算，模糊匹配中%的加入势必会导致hash计算的时候没法找到对应的hash索引位置，所以没法实现。<br>对于数组这种数据结构，对于随机查询和范围查询性能都是比较好，但是一旦涉及到数据的增加，删除的时候会牵扯到数据的搬迁，而且数据需要声明连续的空间地址，条件比较苛刻。<br>接下来考虑的就是使用树来存储，为什么没有使用二叉树呢？对于二叉树来说查找数据的时间复杂度是O(logN)与树高成正比，二叉树很深，每走一层就是一次IO，这就会导致查找数据的IO次数很多，于是进行了优化采用B-树的形式，也就是多叉树，这样就让一层存放多个节点极大的减小了树高，从而减小IO次数。<br>那最终为什么使用B+树而不是B-树？B+和所有的数据都存在了叶子节点，而B-树的数据在叶子结点和非叶子结点都会存储。不同的存储方式带来了几点差异：</p><ol><li>B+树的数据只会存在叶子结点，这样就会让查询的结果就是在叶子节点这一层查到数据，但是B-树查到数据的层级并不是一致的，这就导致了IO的跳跃性，。</li><li>B+树的非叶子节点都不存储数据，这就让B+树能够存储更多的数据，让B+树更加矮胖，提高了磁盘的利用率。</li><li>B+树的叶子节点是通过链表进行连接的，通过这种方式更有利于范围查询。</li><li>B+树中非叶子节点的数据可能存在冗余数据，删除数据的时候能够跟好的保持平衡性，不需要大量的结构调整。<br>对于为什么不采用跳表我们可以在redis的专栏中在讨论，因为面试官可能问为什么redis中有使用跳表实现而不是B+树？</li></ol><h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>根据列形式分为：单列索引和联合索引；<br>根据功能逻辑分为：普通索引，唯一索引，主键索引和全文索引；<br>（什么是唯一索引？和主键索引区别？ 唯一索引是在普通索引的基础上添加了unique的唯一性约束，主键索引则是在唯一索引的基础上增加了NOT NULL不为空的约束）<br>根据实现分为聚簇索引和非聚簇索引；<br>（什么是聚簇索引？和非聚簇索引有什么区别？这里我们需要结合索引存储结构的value来区分，首先说结论：聚簇索引存储的值是整行数据，而非聚簇索引存储的值是主键值；这种存储方式导致回表的问题）<br>根据结构分为前面提到的B+索引和哈希索引。<br>什么样的字段适合作为索引？什么时候会出现索引失效，能举例说明吗？<br>不论是索引还是目录，想要提升查找效率的方式就是通过<strong>区分度</strong>，所以一般情况下区分度更高的字段适合作为索引，例如性别这类字段区分度就不是很高，而身份证号码这种字段的唯一性就让它非常适合作为索引（这里的适合指的是从区分度层面）。当然事无绝对，有时候在使用覆盖索引的时候也会包括一下区分度并不是那么高的字段。<br>索引这么高效，在使用的时候同样需要小心无意造成的失效场景，下面画的图中包括了一些常见的失效场景，我们一起来看看。</p><ol><li>表达式运算导致失效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure>以这种情况为例，age字段进行了表达式运算就会导致age索引失效，这是因为在我们没法利用索引树进行快速地查找，每次需要先运算然后比较。</li><li>索引列使用函数导致失效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">YEAR</span>(birthday) <span class="hljs-operator">=</span> <span class="hljs-number">1990</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> Length(name)<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>函数导致索引失效的原因和表达式运算也是非常类似的，因为我们索引树查找的时候是进行比较查找，使用了函数就需要进行额外的运算等操作，这就导致了没法直接开始查找。</li><li>隐式类型转换导致失效<br>我们先看一下这两个例子，自己判断一下索引是否失效？<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> phone_number <span class="hljs-operator">=</span> <span class="hljs-number">1596811</span>; （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> card_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>; （<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure>现在公布结果：（1）会失效，（2）不会失效。其实类型转换导致索引失效的原因和函数是一样的，因为存在CAST和CONVERT() 函数，看下面展开的SQL相信你就可以理解了。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">CAST</span>(phone_number <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>)phone_number <span class="hljs-operator">=</span> <span class="hljs-number">1596811</span>; （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> card_id <span class="hljs-operator">=</span> <span class="hljs-built_in">CAST</span>(<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>); （<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure></li><li>LIKE进行模糊匹配的时候使用”%…”导致失效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%三&#x27;</span>;<br></code></pre></td></tr></table></figure>这是因为like子句使用%开头就相当于所有数据都匹配的情况，相当于进行了全表扫描。</li><li>WHERE条件判断中使用OR左右两边有一个字段没有加索引会导致失效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cloter&#x27;</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure>以上SQL只有name和age都是索引列的时候能走索引，否则会导致索引失效。</li><li>最左匹配原则导致失效<br>现在有联合索引 (a, b, c), (c, b, a), (a, c), (b, c) 你来判断一下哪些联合索引生效。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>所谓的最左匹配原则就是我们创建的联合索引和我们SQL中的字段顺序相匹配就能够使用，但是这里需要注意一个问题，MySQL中有优化器的存在，(a, b, c), (c, b, a)这两种联合索引对于上面的SQL会进行顺序的优化，都会优化为(a, b, c)，所以两者都是能够用上索引的，但是对于 (a, c)只能匹配到a索引，（b, c）则不走索引。以上是等值的情况，对于不等的情况也有所不同，我们接着往下看：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> a <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; (<span class="hljs-number">1</span>)<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> a <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; (<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>对于以上两个SQL，我们还是创建了(a, b, c)这个联合索引，最终结果是(1)只能使用到a索引，而(2)能够使用到整个联合索引。<blockquote><p>联合索引遇到范围查询例如&gt; &lt;匹配过程就会停止；创建联合索引的时候我们应该尽可能把区分度高的字段放前面；另外需要注意的就是&#x3D;查询的字段如果和联合索引不一致，mysql优化器会起作用，这时候就还是能用上索引。但是对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，是可以用到索引的。<br>除了上面说到的失效场景，还有在使用NULL或者NOT NULL等场景也会出现，其他场景也是类似的。</p></blockquote></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是由 MySQL中索引有了解吗？ 引出的一些列知识点，如果有什么问题的话欢迎在评论区交流讨论！</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎来到ykh的个人博客</title>
    <link href="/2024/04/30/hello-world/"/>
    <url>/2024/04/30/hello-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是本人搭建个人博客，主要用于技术学习的记录和分享。后续会在这个平台分享包括但不限于后端技术内容，欢迎大家多多捧场。第一篇博客主要介绍本人的一些转码的感悟，其中也会包括一些自己的思考。欢迎大家一起交流，无论是职业规划还是学业交流。</p></blockquote><span id="more"></span><h2 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h2><p>&emsp;&emsp;大家好！我本科就读于化工与制药专业的双非，硕士专业是化学系985。本科期间并没有对未来职业规划有明确的目标，所以只是希望硕士读一个江浙沪的学校；在研一的时候“幡然醒悟”，觉得应该作出改变，仔细思考未来做什么。于是花了一段时间思考，做出“转码”的决定。我转码90%原因就是因为赚的多，这里的赚的多是同等程度下和我本专业相比(如果读者不认同，请不要抬杠说xxx同样化学专业收入是计算的xxx倍)这里并不提倡人人转码，只是记录自己的转码过程和经验分享。</p><h2 id="参与思考"><a href="#参与思考" class="headerlink" title="参与思考"></a>参与思考</h2><p>&emsp;&emsp;为了避免大家少走弯路，希望大家对未来的职业有一个明确的规划。所以在这里有几个问题供大家自问自答，回答了这几个问题你就会知道自己跟适合什么职业，更希望什么生活：</p><ol><li>你来学校是为了什么？</li><li>你毕业了想成为什么样的人？</li><li>你希望成为的人所过的生活你可以一直接受吗？<br><img src="/img/2.jpg"><br>&emsp;&emsp;对于第一个问题可以是为了化学科研做贡献，希望学会一技之长，有些人说我就是为了混混毕业，我觉得都是可以的，我不会站在道德的制高点指责对错。第二个问题你可以是希望做一个有钱人，也可以是成为权利的中心，也可以是教师也可以是医生。第三个问题是对前面问题的自我审视，例如我希望成为权利的中心，需要拥有优秀的人际关系处理能力；我希望成为某个领域的科研专家，需要解释领域的大牛，需要social，需要paper等等，如果你觉得都是OK，可以长久坚持并付诸努力的完全没问题。<br>&emsp;&emsp;通过三个问题的自问自答，你或许能够知道自己是什么样的人，想过什么样的生活，是什么性格的人。如果对你有所帮助或者有所启发的话欢迎评论点赞。</li></ol>]]></content>
    
    
    <categories>
      
      <category>自我思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学会思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
