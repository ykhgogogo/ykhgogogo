<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试&quot;亿&quot;问：MySQL中索引有了解吗？</title>
    <link href="/2024/07/05/2024-09-15/"/>
    <url>/2024/07/05/2024-09-15/</url>
    
    <content type="html"><![CDATA[<p>MySQL是后端面试的常考知识点，其中高频的知识点一定少不了<span style="color:red;"><strong>索引</strong></span>。当面试官问到索引你有了解吗，我们的回答一定是有！我们回答这类问题的时候应该带着引导性的回答。</p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p><img src="/img/4.jpg"></p><p>索引这个概念我们可以其实和生活中字典的<strong>目录</strong>进行类比，索引就是起到了类似的作用，帮助我们在数据库表中快速的找到对应的数据，因为开发者在设计MySQL的时候核心思想之一是<span style="color:red;"><strong>减少IO</strong></span>。在MySQL中索引存储的数据结构是B+树，在进行增删改查的时候时间复杂度是<strong>O(logN)</strong>，IO次数等于树高。索引根据不同的分类方式，他也有多种索引类型后面再讨论。同时作为开发者我们在使用索引，或是选择索引的时候需要知道应该选择什么字段适合作为索引、什么时候会导致索引失效、如何优化索引等一系列问题。</p><p>通过上面的介绍，我们能够引出的场景问题包括但不限于：</p><blockquote><ol><li>索引的存储结构是什么？</li><li>为什么选择B+树作为索引结构？</li><li>B+树索引相较于B树索引&#x2F;二叉树索引&#x2F;哈希索引的优势？</li><li>MySQL查找一条数据的过程是怎么样？</li><li>MySQL为什么采用B+树存储而不是跳表？</li></ol></blockquote><h2 id="索引在MySQL中的存储形式"><a href="#索引在MySQL中的存储形式" class="headerlink" title="索引在MySQL中的存储形式"></a>索引在MySQL中的存储形式</h2><p><img src="/img/tree.jpg"></p><p>第一个问题MySQL的索引是以B+树的形式进行存储。</p><p>第二个问题结合第三个问题可以结合起来回答。对于提到的几种数据结构我们可以对比着看。</p><p>问题的答案我们还是围绕MySQL索引结构设计的核心思想是为了<strong>减少IO</strong>。</p><p>假设我们现在MySQL以哈希表进行存储，这时候进行等值查询的效率非常高，时间复杂度为O(1)。这是哈希表的优势；但是哈希表没法进行范围查询相信大家都知道，再进一步哈希索引对于联合索引，模糊匹配，最左匹配这些功能都没发很好的支持。以模糊匹配为例说明原因：哈希表存储的时候会对key进行hash计算，模糊匹配中%的存在会导致hash计算的时候没法找到对应的hash索引位置，所以没法实现。</p><p>对于数组这种数据结构，对于随机查询和范围查询性能都是比较好，但是一旦涉及到数据的增加，删除的时候会牵扯到数据的搬迁，而且数据需要声明连续的空间地址，条件比较苛刻。</p><p>接下来考虑的就是使用树来存储，为什么没有使用二叉树呢？对于二叉树来说查找数据的时间复杂度是<strong>O(logN)</strong>与树高成正比，二叉树很深，每走一层就是一次IO，这就会导致查找数据的IO次数很多，于是进行了优化采用B&#x2F;B-树的形式，也就是多叉树，这样就让一层存放多个节点极大的减小了树高，从而减小IO次数。<br>那最终为什么使用B+树而不是B&#x2F;B-树？B+树所有的数据都存在了叶子节点，而B&#x2F;B-树的数据在叶子结点和非叶子结点都会存储。不同的存储方式带来了几点差异：</p><ol><li><p>B+树的数据只会存在叶子结点，这样就会让查询的结果都在叶子节点这一层查到，但是B&#x2F;B-树查到数据的层级并不是一致的，这就导致了IO的跳跃性和随机性。</p></li><li><p>B+树的非叶子节点都不存储数据，这就让B+树能够存储更多的数据，让B+树更加矮胖，提高了磁盘的利用率的同时尽可能减少了树高，更加矮胖则意味着IO的减少。</p></li><li><p>B+树叶子节点内的数据是通过单链表进行连接的，通过这种方式更有利于范围查询；而B&#x2F;B-不是统一分布在叶子结点，范围查找不能够根据第一个结构直接往后遍历查找。</p></li><li><p>B+树中非叶子节点的数据可能存在冗余数据，删除数据的时候能够跟好的保持平衡性，不需要大量的结构调整。<br><img src="/img/B+.jpg"></p><blockquote><p>对于为什么不采用跳表我们可以在redis专栏中再讨论，因为面试官可能问为什么redis中有使用跳表实现而不是B+树？</p></blockquote></li></ol><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>根据<strong>列形式</strong>分为：单列索引和联合索引</p><p>根据<strong>功能逻辑</strong>分为：普通索引，唯一索引，主键索引和全文索引</p><p>按照<strong>物理存储</strong>方式分为：聚集索引和非聚集索引</p><p>按照<strong>结构</strong>还可以分为：B+索引，hash索引</p><blockquote><ol><li>什么是唯一索引？和主键索引区别？</li></ol></blockquote><blockquote><p>唯一索引是在普通索引的基础上添加了unique的唯一性约束，主键索引则是在唯一索引的基础上增加了NOT NULL不为空的约束根据实现分为聚簇索引和非聚簇索引；</p></blockquote><blockquote><ol start="2"><li>什么是聚簇索引？和非聚簇索引有什么区别？</li></ol></blockquote><blockquote><p>这里我们需要结合索引存储结构的value来区分，首先说结论：聚簇索引存储的值是整行数据，而非聚簇索引存储的值是主键值；这种存储方式导致<strong>回表</strong>的问题</p></blockquote><h2 id="什么样的字段适合作为索引"><a href="#什么样的字段适合作为索引" class="headerlink" title="什么样的字段适合作为索引"></a>什么样的字段适合作为索引</h2><p>不论是索引还是目录，提升查找效率的方式就是通过<strong>区分度</strong>，所以一般情况下区分度更高的字段适合作为索引，例如<strong>性别</strong>这类字段区分度就不是很高，而身份证号码这种字段的唯一性就比较适合作为索引（这里的适合指的是从区分度层面）。当然事无绝对，有时候在使用覆盖索引的时候也会包括一下区分度并不是那么高的字段；还有一些条件例如不会频繁修改的字段、不为NULL的字段等。</p><h2 id="索引失效-举例说明"><a href="#索引失效-举例说明" class="headerlink" title="索引失效 举例说明"></a>索引失效 举例说明</h2><p>索引这么高效，在使用的时候同样需要小心无意造成的失效场景，下面例举了一些常见的失效场景，我们一起来看看。</p><ol><li>表达式运算导致失效</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure><p>以这种情况为例，age字段进行了表达式运算就会导致age索引失效，这是因为在我们没法利用索引树进行快速地查找，每次需要先运算然后比较。</p><ol start="2"><li>索引列使用函数导致失效</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">YEAR</span>(birthday) <span class="hljs-operator">=</span> <span class="hljs-number">1990</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> Length(name) <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>函数导致索引失效的原因和表达式运算也是非常类似的，因为我们索引树查找的时候是进行比较查找，使用了函数就需要进行额外的运算等操作，这就导致了没法直接开始查找。</p><ol start="3"><li>隐式类型转换导致失效</li></ol><p>我们先看一下这两个例子，自己判断一下索引是否失效？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> phone_number <span class="hljs-operator">=</span> <span class="hljs-number">1596811</span>; （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> card_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>; （<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure><p>结果：（1）会失效，（2）不会失效。类型转换导致索引失效的原因和函数是一样的，因为存在CAST和CONVERT()函数，看下面展开的SQL相信你就可以理解了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">CAST</span>(phone_number <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>)phone_number <span class="hljs-operator">=</span> <span class="hljs-number">1596811</span>; （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> card_id <span class="hljs-operator">=</span> <span class="hljs-built_in">CAST</span>(<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>); （<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure><ol start="4"><li>LIKE进行模糊匹配的时候使用”%…”导致失效</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%三&#x27;</span>;<br></code></pre></td></tr></table></figure><p>因为like子句使用%开头就相当于所有数据都匹配的情况，相当于进行了全表扫描。</p><ol start="5"><li>WHERE条件判断中使用OR左右两边有一个字段没有加索引会导致失效</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cloter&#x27;</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure><p>以上SQL只有name和age都是索引列的时候能走索引，否则会导致索引失效。</p><ol start="6"><li>最左匹配原则导致失效</li></ol><p>现在有联合索引 (a, b, c), (c, b, a), (a, c), (b, c) 你来判断一下哪些联合索引生效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>所谓的最左匹配原则就是我们创建的联合索引和我们SQL中字段顺序相匹配才够使用，但是这里需要注意一个问题，MySQL中有优化器的存在，SQL中(a, b, c), (c, b, a)这两种顺序会优化为(a, b, c)的联合索引，所以两者都是能够用上索引的，但是对于 (a, c)只能匹配到a索引，（b, c）则不走索引。以上是等值的情况，对于不等的情况也有所不同，我们接着往下看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> a <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; (<span class="hljs-number">1</span>)<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> a <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; (<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>对于以上两个SQL，我们还是创建了(a, b, c)这个联合索引，最终结果是(1)只能使用到a索引，而(2)能够使用到整个联合索引。<br>联合索引遇到范围查询例如&gt; &lt;匹配过程就会停止；创建联合索引的时候我们应该尽可能把区分度高的字段放前面；另外需要注意的是对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，是可以用到索引的。除了上面说到的失效场景，还有在使用NULL或者NOT NULL等场景也会出现，其他场景也是类似的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是由MySQL中索引引出的一些列知识点，当然还会有很多问题没有覆盖，我会在后续的文章中慢慢补全，一人写作不易如果存在错误还请大家指出，也欢迎在评论区交流讨论！</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎来到ykh的个人博客</title>
    <link href="/2024/04/30/hello-world/"/>
    <url>/2024/04/30/hello-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是本人搭建个人博客，主要用于技术学习的记录和分享。后续会在这个平台分享包括但不限于后端技术内容，欢迎大家多多捧场。第一篇博客主要介绍本人的一些转码的感悟，其中也会包括一些自己的思考。欢迎大家一起交流，无论是职业规划还是学业交流。</p></blockquote><span id="more"></span><h2 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h2><p>&emsp;&emsp;大家好！我本科就读于化工与制药专业的双非，硕士专业是化学系985。本科期间并没有对未来职业规划有明确的目标，所以只是希望硕士读一个江浙沪的学校；在研一的时候“幡然醒悟”，觉得应该作出改变，仔细思考未来做什么。于是花了一段时间思考，做出“转码”的决定。我转码90%原因就是因为赚的多，这里的赚的多是同等程度下和我本专业相比(如果读者不认同，请不要抬杠说xxx同样化学专业收入是计算的xxx倍)这里并不提倡人人转码，只是记录自己的转码过程和经验分享。</p><h2 id="参与思考"><a href="#参与思考" class="headerlink" title="参与思考"></a>参与思考</h2><p>&emsp;&emsp;为了避免大家少走弯路，希望大家对未来的职业有一个明确的规划。所以在这里有几个问题供大家自问自答，回答了这几个问题你就会知道自己跟适合什么职业，更希望什么生活：</p><ol><li>你来学校是为了什么？</li><li>你毕业了想成为什么样的人？</li><li>你希望成为的人所过的生活你可以一直接受吗？<br><img src="/img/2.jpg"><br>&emsp;&emsp;对于第一个问题可以是为了化学科研做贡献，希望学会一技之长，有些人说我就是为了混混毕业，我觉得都是可以的，我不会站在道德的制高点指责对错。第二个问题你可以是希望做一个有钱人，也可以是成为权利的中心，也可以是教师也可以是医生。第三个问题是对前面问题的自我审视，例如我希望成为权利的中心，需要拥有优秀的人际关系处理能力；我希望成为某个领域的科研专家，需要解释领域的大牛，需要social，需要paper等等，如果你觉得都是OK，可以长久坚持并付诸努力的完全没问题。<br>&emsp;&emsp;通过三个问题的自问自答，你或许能够知道自己是什么样的人，想过什么样的生活，是什么性格的人。如果对你有所帮助或者有所启发的话欢迎评论点赞。</li></ol>]]></content>
    
    
    <categories>
      
      <category>自我思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学会思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
